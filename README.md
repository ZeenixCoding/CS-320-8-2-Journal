# CS-320-8-2-Journal
Portfolio item submission.
Ryan Oâ€™Toole
October 2025

This course gave me a better understanding of how to test software efficiently and build reliable systems. Through the Contact Service and Summary & Reflections Report projects, I learned how testing fits into the overall development process and how careful design choices can prevent issues before they happen.

How can I ensure that my code, program, or software is functional and secure?
I make sure my code is functional by testing each part individually and validating that it behaves the way it is supposed to. Writing unit tests in JUnit helped me catch logic errors early and confirm that updates did not break existing functionality. I also focus on using clear input validation and defensive coding practices to make the software more secure. Things like null checks, input limits, and exception handling go a long way in preventing unexpected behavior.

How do I interpret user needs and incorporate them into a program?
I start by breaking down the requirements into smaller, testable goals. For example, in the Contact Service project, the user needed a way to manage contact information with specific rules for IDs, names, and phone numbers. Translating those needs into constraints and tests helped ensure the final code matched what the user expected. I have learned that the best way to meet user needs is to stay organized, confirm requirements early, and test against them throughout development.

How do I approach designing software?
When designing software, I focus on simplicity, structure, and maintainability. I try to design classes and methods that have one clear purpose, which makes them easier to test and debug. I also think ahead about scalability, making sure the code can handle future updates without breaking existing parts. Starting with clear requirements, writing tests first when possible, and refining the design through feedback has made my work cleaner and more reliable overall.

These projects showed me how important testing and reflection are in becoming a stronger developer. They reinforced the value of writing clean, maintainable code and using testing as a tool not just to find bugs, but to build confidence in the software I create.
